

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Problem class &#8212; pygmo 2.19.5 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'problem';</script>
    <link rel="shortcut icon" href="_static/logo_favico.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Population class" href="population.html" />
    <link rel="prev" title="Algorithm class" href="algorithm.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    <p class="title logo__title">pygmo 2.19.5 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Capabilities</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="tutorials/tutorials.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials/using_problem.html">Use of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/using_algorithm.html">Use of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">algorithm</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/using_population.html">Use of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">population</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/using_island.html">Use of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">island</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/using_archipelago.html">Use of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">archipelago</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/evolving_a_population.html">Evolving a population</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/coding_udp_simple.html">Coding a simple User Defined Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/coding_udp_constrained.html">Coding a User Defined Problem with constraints (NLP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/coding_udp_minlp.html">Coding a User Defined Problem with an integer part (MINLP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/coding_udp_multi_objective.html">Coding a User Defined Problem with multiple objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/udp_meta_decorator.html">Using the decorator meta-problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/coding_udi.html">Coding a User Defined Island</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/nlopt_basics.html">A first tutorial on the use of NLopt solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/moo.html">Basic Multi-Objective Functionalities</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/moo_moead.html">Using pygmoâ€™s <code class="xref py py-class docutils literal notranslate"><span class="pre">moead</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/hypervolume.html">Getting started with hypervolumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/hypervolume_advanced.html">Advanced hypervolume computation and analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/hypervolume_approx.html">Approximating the hypervolume</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/cec2006_gaco_benchmark.html">Benchmarking Extended Ant Colony Optimization on CEC2006 problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/cec2013_comp.html">Participating to the CEC2013 Competition</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/solving_schwefel_20.html">Solving the 20 dimensional Schwefel problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/cmaes_vs_xnes.html">Comparing algorithms: the case of xNES and CMA-ES</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/zdt3_maco_benchmark.html">Benchmarking Multi-Objective Hypervolume-based Ant Colony Optimization on ZDT3 problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/nspso_tutorial_zdt1_2.html">Benchmarking Nondominated Sorting Particle Swarm Optimizer (NSPSO) on ZDT1 and ZDT2 problems</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="api_reference.html">API reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="algorithm.html">Algorithm class</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Problem class</a></li>
<li class="toctree-l2"><a class="reference internal" href="population.html">Population class</a></li>
<li class="toctree-l2"><a class="reference internal" href="island.html">Island class</a></li>
<li class="toctree-l2"><a class="reference internal" href="archipelago.html">Archipelago class</a></li>
<li class="toctree-l2"><a class="reference internal" href="bfe.html">Batch fitness evaluator</a></li>
<li class="toctree-l2"><a class="reference internal" href="topology.html">Topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="r_policy.html">Replacement policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="s_policy.html">Selection policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Miscellanea</a></li>
<li class="toctree-l2"><a class="reference internal" href="problems.html">List of problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html">List of algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="islands.html">List of islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="bfes.html">List of batch evaluators</a></li>
<li class="toctree-l2"><a class="reference internal" href="topologies.html">List of topologies</a></li>
<li class="toctree-l2"><a class="reference internal" href="r_policies.html">List of replacement policies</a></li>
<li class="toctree-l2"><a class="reference internal" href="s_policies.html">List of selection policies</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_utils.html">Generic optimization utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="mo_utils.html">Multi-objective optimization utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="con_utils.html">Constrained optimization utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="gh_utils.html">Gradient and Hessians utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="hv_utils.html">Hypervolume utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="genetic_op_utils.html">Generic optimization utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotting.html">Plotting utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="known_issues.html">Known issues</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/esa/pygmo2" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/esa/pygmo2/issues/new?title=Issue%20on%20page%20%2Fproblem.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/problem.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Problem class</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="problem-class">
<h1>Problem class<a class="headerlink" href="#problem-class" title="Permalink to this headline">#</a></h1>
<img alt="_images/prob_no_text.png" src="_images/prob_no_text.png" />
<dl class="py class">
<dt class="sig sig-object py" id="pygmo.problem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygmo.</span></span><span class="sig-name descname"><span class="pre">problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">udp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">null_problem()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem" title="Permalink to this definition">#</a></dt>
<dd><p>Problem class.</p>
<p>This class represents a generic <em>mathematical programming</em> or <em>evolutionary optimization</em> problem in the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
\mbox{find:}      &amp; \mathbf {lb} \le \mathbf x \le \mathbf{ub}\\
\mbox{to minimize: } &amp; \mathbf f(\mathbf x, s) \in \mathbb R^{n_{obj}}\\
\mbox{subject to:} &amp; \mathbf {c}_e(\mathbf x, s) = 0 \\
                  &amp; \mathbf {c}_i(\mathbf x, s) \le 0
\end{array}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf x \in \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> is called <em>decision vector</em> or
<em>chromosome</em>, and is made of <span class="math notranslate nohighlight">\(n_{cx}\)</span> real numbers and <span class="math notranslate nohighlight">\(n_{ix}\)</span> integers (all represented as doubles). The
total problem dimension is then indicated with <span class="math notranslate nohighlight">\(n_x = n_{cx} + n_{ix}\)</span>. <span class="math notranslate nohighlight">\(\mathbf{lb}, \mathbf{ub} \in
\mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> are the <em>box-bounds</em>, <span class="math notranslate nohighlight">\(\mathbf f: \mathbb R^{n_{cx}} \times
\mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{obj}}\)</span> define the <em>objectives</em>, <span class="math notranslate nohighlight">\(\mathbf c_e:  \mathbb R^{n_{cx}}
\times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ec}}\)</span> are non linear <em>equality constraints</em>, and <span class="math notranslate nohighlight">\(\mathbf
c_i:  \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ic}}\)</span> are non linear <em>inequality
constraints</em>. Note that the objectives and constraints may also depend from an added value <span class="math notranslate nohighlight">\(s\)</span> seeding the
values of any number of stochastic variables. This allows also for stochastic programming tasks to be represented by
this class. A tolerance is also considered for all constraints and set, by default, to zero. It can be modified
via the <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a> attribute.</p>
<p>In order to define an optimizaztion problem in pygmo, the user must first define a class
whose methods describe the properties of the problem and allow to compute
the objective function, the gradient, the constraints, etc. In pygmo, we refer to such
a class as a <strong>user-defined problem</strong>, or UDP for short. Once defined and instantiated,
a UDP can then be used to construct an instance of this class, <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>, which
provides a generic interface to optimization problems.</p>
<p>Every UDP must implement at least the following two methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method is expected to return the fitness of the input decision vector (concatenating
the objectives, the equality and the inequality constraints), while
<code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> is expected to return the box bounds of the problem,
<span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span>, which also implicitly define the dimension of the problem.
The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> and <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> methods of the UDP are accessible from the corresponding
<a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.fitness()</span></code></a> and <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.get_bounds()</span></code></a>
methods (see their documentation for information on how the two methods should be implemented
in the UDP and other details).</p>
<p>The two mandatory methods above allow to define a single objective, deterministic, derivative-free, unconstrained
optimization problem. In order to consider more complex cases, the UDP may implement one or more of the following
methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_nobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dvs</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_extra_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>See the documentation of the corresponding methods in this class for details on how the optional
methods in the UDP should be implemented and on how they are used by <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.
Note that the exposed C++ problems can also be used as UDPs, even if they do not expose any of the
mandatory or optional methods listed above (see <a class="reference internal" href="problems.html#problems"><span class="std std-ref">here</span></a> for the
full list of UDPs already coded in pygmo).</p>
<p>This class is the Python counterpart of the C++ class <a class="reference external" href="https://esa.github.io/pagmo2/docs/cpp/problem.html#_CPPv4N5pagmo7problemE" title="(in pagmo v2.19.0)"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">pagmo::problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>udp</strong> â€“ a user-defined problem, either C++ or Python</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><strong>NotImplementedError</strong></a> â€“ if <em>udp</em> does not implement the mandatory methods detailed above</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if the number of objectives of the UDP is zero, the number of objectives,
    equality or inequality constraints is larger than an implementation-defined value,
    the problem bounds are invalid (e.g., they contain NaNs, the dimensionality of the lower bounds is
    different from the dimensionality of the upper bounds, etc. - note that infinite bounds are allowed),
    or if the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> and <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> methods of the UDP fail basic sanity checks
    (e.g., they return vectors with repeated indices, they contain indices exceeding the problemâ€™s dimensions, etc.)</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by methods of the UDP invoked during construction,
    the deep copy of the UDP, the constructor of the underlying C++ class,
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.batch_fitness">
<span class="sig-name descname"><span class="pre">batch_fitness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dvs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.batch_fitness" title="Permalink to this definition">#</a></dt>
<dd><p>This method implements the evaluation of multiple decision vectors in batch mode
by invoking the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP accepts in input a batch of decision vectors, <em>dvs</em>, stored contiguously:
for a problem with dimension <span class="math notranslate nohighlight">\(n\)</span>, the first decision vector in <em>dvs</em> occupies
the index range <span class="math notranslate nohighlight">\(\left[0, n\right)\)</span>, the second decision vector occupies the range
<span class="math notranslate nohighlight">\(\left[n, 2n\right)\)</span>, and so on. The return value is the batch of fitness vectors <em>fvs</em>
resulting from computing the fitness of the input decision vectors.
<em>fvs</em> is also stored contiguously: for a problem with fitness dimension <span class="math notranslate nohighlight">\(f\)</span>, the first fitness
vector will occupy the index range <span class="math notranslate nohighlight">\(\left[0, f\right)\)</span>, the second fitness vector
will occupy the range <span class="math notranslate nohighlight">\(\left[f, 2f\right)\)</span>, and so on.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, this method will forward <code class="docutils literal notranslate"><span class="pre">dvs</span></code>
to the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP will also be checked before being returned. If the UDP does not provide a
<code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, an error will be raised.</p>
<p>A successful call of this method will increase the internal fitness evaluation counter
(see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP must be able to take as input the decision vectors as a 1D NumPy array,
and it must return the fitness vectors as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dvs</strong> (<em>array-like object</em>) â€“ the decision vectors (chromosomes) to be evaluated in batch mode</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the fitness vectors of <em>dvs</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if <em>dvs</em> and/or the return value are not compatible with the problemâ€™s properties</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygmo.problem.c_tol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">c_tol</span></span><a class="headerlink" href="#pygmo.problem.c_tol" title="Permalink to this definition">#</a></dt>
<dd><p>Constraints tolerance.</p>
<p>This property contains an array of <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> that are used when checking for constraint feasibility.
The dimension of the array is <span class="math notranslate nohighlight">\(n_{ec} + n_{ic}\)</span> (i.e., the total number of constraints), and
the array is zero-filled on problem construction.</p>
<p>This property can also be set via a scalar, instead of an array. In such case, all the tolerances
will be set to the provided scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the constraintsâ€™ tolerances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if, when setting this property, the size of the input array differs from the number
    of constraints of the problem or if any element of the array is negative or NaN</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by failures at the intersection between C++ and Python (e.g.,
    type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygmo</span> <span class="kn">import</span> <span class="n">problem</span><span class="p">,</span> <span class="n">hock_schittkowski_71</span> <span class="k">as</span> <span class="n">hs71</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span> <span class="o">=</span> <span class="n">problem</span><span class="p">(</span><span class="n">hs71</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="mf">.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0.5, 0.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.extract">
<span class="sig-name descname"><span class="pre">extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.extract" title="Permalink to this definition">#</a></dt>
<dd><p>Extract the user-defined problem.</p>
<p>This method allows to extract a reference to the user-defined problem (UDP) stored within this
<a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a> instance. The behaviour of this function depends on the value
of <em>t</em> (which must be a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) and on the type of the internal UDP:</p>
<ul class="simple">
<li><p>if the type of the UDP is <em>t</em>, then a reference to the UDP will be returned
(this mirrors the behaviour of the corresponding C++ method
<a class="reference external" href="https://esa.github.io/pagmo2/docs/cpp/problem.html#_CPPv4I0ENK5pagmo7problem7extractEPK1Tv" title="(in pagmo v2.19.0)"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pagmo::problem::extract()</span></code></a>),</p></li>
<li><p>if <em>t</em> is <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> and the UDP is a Python object (as opposed to an
<a class="reference internal" href="problems.html#problems-cpp"><span class="std std-ref">exposed C++ problem</span></a>), then a reference to the
UDP will be returned (this allows to extract a Python UDP without knowing its type),</p></li>
<li><p>otherwise, <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> will be returned.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) â€“ the type of the user-defined problem to extract</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a reference to the internal user-defined problem, or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> if the extraction fails</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><strong>TypeError</strong></a> â€“ if <em>t</em> is not a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> 
<span class="go">&lt;pygmo.core.rosenbrock at 0x7f56b870fd50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">ackley</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">prob</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">prob</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> 
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> 
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.feasibility_f">
<span class="sig-name descname"><span class="pre">feasibility_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_f" title="Permalink to this definition">#</a></dt>
<dd><p>This method will check the feasibility of a fitness vector <em>f</em> against the tolerances returned by
<a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>array-like object</em>) â€“ a fitness vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the fitness vector is feasible, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if the size of <em>f</em> is not the same as the output of
    <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.feasibility_x">
<span class="sig-name descname"><span class="pre">feasibility_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_x" title="Permalink to this definition">#</a></dt>
<dd><p>This method will check the feasibility of the fitness corresponding to a decision vector <em>x</em> against
the tolerances returned by <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<p>This will cause one fitness evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) â€“ a decision vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> results in a feasible fitness, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> â€“ any exception thrown by <a class="reference internal" href="#pygmo.problem.feasibility_f" title="pygmo.problem.feasibility_f"><code class="xref py py-func docutils literal notranslate"><span class="pre">feasibility_f()</span></code></a> or
    <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.fitness">
<span class="sig-name descname"><span class="pre">fitness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.fitness" title="Permalink to this definition">#</a></dt>
<dd><p>Fitness.</p>
<p>This method will invoke the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP to compute the fitness of the
input decision vector <em>dv</em>. The return value of the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP is expected to have a
dimension of <span class="math notranslate nohighlight">\(n_{f} = n_{obj} + n_{ec} + n_{ic}\)</span> and to contain the concatenated values of
<span class="math notranslate nohighlight">\(\mathbf f, \mathbf c_e\)</span> and <span class="math notranslate nohighlight">\(\mathbf c_i\)</span> (in this order).
Equality constraints are all assumed in the form <span class="math notranslate nohighlight">\(c_{e_i}(\mathbf x) = 0\)</span> while inequalities are assumed in
the form <span class="math notranslate nohighlight">\(c_{i_i}(\mathbf x) &lt;= 0\)</span> so that negative values are associated to satisfied inequalities.</p>
<p>In addition to invoking the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, this method will perform sanity checks on
<em>dv</em> and on the returned fitness vector. A successful call of this method will increase the internal fitness
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy array, and it must
return the fitness vector as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) â€“ the decision vector (chromosome) to be evaluated</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the fitness of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of the returned fitness vector differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_bounds">
<span class="sig-name descname"><span class="pre">get_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_bounds" title="Permalink to this definition">#</a></dt>
<dd><p>Box-bounds.</p>
<p>This method will return the box-bounds <span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span> of the problem,
as returned by the <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP. Infinities in the bounds are allowed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP must return the box-bounds as a tuple of 2 elements,
the lower bounds vector and the upper bounds vector, which must be represented as iterable Python objects (e.g.,
1D NumPy arrays, lists, tuples, etc.). The box-bounds returned by the UDP are checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple of two 1D NumPy float arrays representing the lower and upper box-bounds of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> â€“ any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_extra_info">
<span class="sig-name descname"><span class="pre">get_extra_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_extra_info" title="Permalink to this definition">#</a></dt>
<dd><p>Problemâ€™s extra info.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code>
method. Otherwise, an empty string will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>extra info about the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> â€“ any exception thrown by the <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method of the UDP</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_fevals">
<span class="sig-name descname"><span class="pre">get_fevals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_fevals" title="Permalink to this definition">#</a></dt>
<dd><p>Number of fitness evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_gevals">
<span class="sig-name descname"><span class="pre">get_gevals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_gevals" title="Permalink to this definition">#</a></dt>
<dd><p>Number of gradient evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_hevals">
<span class="sig-name descname"><span class="pre">get_hevals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_hevals" title="Permalink to this definition">#</a></dt>
<dd><p>Number of hessians evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_lb">
<span class="sig-name descname"><span class="pre">get_lb</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_lb" title="Permalink to this definition">#</a></dt>
<dd><p>Lower box-bounds.</p>
<p>This method will return the lower box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the lower box-bounds of this problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> â€“ any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_name" title="Permalink to this definition">#</a></dt>
<dd><p>Problemâ€™s name.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method.
Otherwise, an implementation-defined name based on the type of the UDP will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the problemâ€™s name</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nc">
<span class="sig-name descname"><span class="pre">get_nc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nc" title="Permalink to this definition">#</a></dt>
<dd><p>Total number of constraints.</p>
<p>This method will return the sum of the output of <a class="reference internal" href="#pygmo.problem.get_nic" title="pygmo.problem.get_nic"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nic()</span></code></a> and
<a class="reference internal" href="#pygmo.problem.get_nec" title="pygmo.problem.get_nec"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nec()</span></code></a> (i.e., the total number of constraints).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the total number of constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_ncx">
<span class="sig-name descname"><span class="pre">get_ncx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ncx" title="Permalink to this definition">#</a></dt>
<dd><p>Continuous dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{cx}\)</span>, the continuous dimension of the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the continuous dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nec">
<span class="sig-name descname"><span class="pre">get_nec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nec" title="Permalink to this definition">#</a></dt>
<dd><p>Number of equality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ec}\)</span>, the number of equality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method of the UDP must return the number of equality constraints as an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method, zero equality constraints will be assumed.
The number of equality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of equality constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nf">
<span class="sig-name descname"><span class="pre">get_nf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nf" title="Permalink to this definition">#</a></dt>
<dd><p>Dimension of the fitness.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{f}\)</span>, the dimension of the fitness, which is the sum of
<span class="math notranslate nohighlight">\(n_{obj}\)</span>, <span class="math notranslate nohighlight">\(n_{ec}\)</span> and <span class="math notranslate nohighlight">\(n_{ic}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the fitness</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nic">
<span class="sig-name descname"><span class="pre">get_nic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nic" title="Permalink to this definition">#</a></dt>
<dd><p>Number of inequality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ic}\)</span>, the number of inequality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method of the UDP must return the number of inequality constraints as an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method, zero inequality constraints will be assumed.
The number of inequality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of inequality constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nix">
<span class="sig-name descname"><span class="pre">get_nix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nix" title="Permalink to this definition">#</a></dt>
<dd><p>Integer dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ix}\)</span>, the integer dimension of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method of the UDP must return the problemâ€™s integer dimension as an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method, a zero integer dimension will be assumed.
The integer dimension returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the integer dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nobj">
<span class="sig-name descname"><span class="pre">get_nobj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nobj" title="Permalink to this definition">#</a></dt>
<dd><p>Number of objectives.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{obj}\)</span>, the number of objectives of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method of the UDP must return the number of objectives as an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method, a single-objective optimizaztion problem
will be assumed. The number of objectives returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of objectives of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_nx">
<span class="sig-name descname"><span class="pre">get_nx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nx" title="Permalink to this definition">#</a></dt>
<dd><p>Dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{x}\)</span>, the dimension of the problem as established by the length of
the bounds returned by <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_thread_safety">
<span class="sig-name descname"><span class="pre">get_thread_safety</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_thread_safety" title="Permalink to this definition">#</a></dt>
<dd><p>Problemâ€™s thread safety level.</p>
<p>This method will return a value of the enum <a class="reference internal" href="misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a> which indicates the thread safety level
of the UDP. Unlike in C++, in Python it is not possible to re-implement this method in the UDP. That is, for C++
UDPs, the returned value will be the value returned by the <code class="docutils literal notranslate"><span class="pre">get_thread_safety()</span></code> method of the UDP. For Python
UDPs, the returned value will be unconditionally <code class="docutils literal notranslate"><span class="pre">none</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the thread safety level of the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>a value of <a class="reference internal" href="misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.get_ub">
<span class="sig-name descname"><span class="pre">get_ub</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ub" title="Permalink to this definition">#</a></dt>
<dd><p>Upper box-bounds.</p>
<p>This method will return the upper box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the upper box-bounds of this problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> â€“ any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient.</p>
<p>This method will compute the gradient of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must return
a sparse representation of the gradient: the <span class="math notranslate nohighlight">\(k\)</span>-th term of the gradient vector
is expected to contain <span class="math notranslate nohighlight">\(\frac{\partial f_i}{\partial x_j}\)</span>, where the pair <span class="math notranslate nohighlight">\((i,j)\)</span>
is the <span class="math notranslate nohighlight">\(k\)</span>-th element of the sparsity pattern (collection of index pairs), as returned by
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, an
error will be raised. A successful call of this method will increase the internal gradient
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_gevals" title="pygmo.problem.get_gevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_gevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the gradient vector as an iterable Python object (e.g., 1D NumPy array,
list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) â€“ the decision vector whose gradient will be computed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the gradient of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the returned gradient vector does not have the same size as the vector returned by
    <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a></p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><strong>NotImplementedError</strong></a> â€“ if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.gradient_sparsity">
<span class="sig-name descname"><span class="pre">gradient_sparsity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient_sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient sparsity pattern.</p>
<p>This method will return the gradient sparsity pattern of the problem. The gradient sparsity pattern is a lexicographically sorted
collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of <span class="math notranslate nohighlight">\(g_{ij} = \frac{\partial f_i}{\partial x_j}\)</span>.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_gradient_sparsity" title="pygmo.problem.has_gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a a dense pattern is assumed and the
returned vector will be <span class="math notranslate nohighlight">\(((0,0),(0,1), ... (0,n_x-1), ...(n_f-1,n_x-1))\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP must return either a 2D NumPy array of integers, or an iterable
Python object of any kind. Specifically:</p>
<ul class="simple">
<li><p>if the returned value is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the returned value is an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the gradient sparsity pattern</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if the NumPy array returned by the UDP does not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of the returned iterable Python object does not consist of a collection of exactly
    2 elements, or the sparsity pattern returned by the UDP is invalid
    (specifically, if it is not strictly sorted lexicographically,
    or if the indices in the pattern are incompatible with the properties of the problem, or if the size of the
    returned pattern is different from the size recorded upon construction)</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.12)"><strong>OverflowError</strong></a> â€“ if the NumPy array returned by the UDP contains integer values which are negative or outside an
    implementation-defined range</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_batch_fitness">
<span class="sig-name descname"><span class="pre">has_batch_fitness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_batch_fitness" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.batch_fitness" title="pygmo.problem.batch_fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">batch_fitness()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_gradient">
<span class="sig-name descname"><span class="pre">has_gradient</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the gradient is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_gradient_sparsity">
<span class="sig-name descname"><span class="pre">has_gradient_sparsity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient_sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the gradient sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the gradient sparsity, pygmo will assume that the sparsity
pattern of the gradient is dense. See <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient sparsity in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_hessians">
<span class="sig-name descname"><span class="pre">has_hessians</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the hessians are available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians are available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_hessians_sparsity">
<span class="sig-name descname"><span class="pre">has_hessians_sparsity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians_sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the hessians sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the hessians sparsity, pygmo will assume that the sparsity
pattern of the hessians is dense. See <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians sparsity in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.has_set_seed">
<span class="sig-name descname"><span class="pre">has_set_seed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_set_seed" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.set_seed" title="pygmo.problem.set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_seed()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.hessians">
<span class="sig-name descname"><span class="pre">hessians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians" title="Permalink to this definition">#</a></dt>
<dd><p>Hessians.</p>
<p>This method will compute the hessians of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must return
a sparse representation of the hessians: the element <span class="math notranslate nohighlight">\(l\)</span> of the returned vector contains
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^2_l}{\partial x_i\partial x_j}\)</span> in the order specified by the
<span class="math notranslate nohighlight">\(l\)</span>-th element of the hessians sparsity pattern (a vector of index pairs <span class="math notranslate nohighlight">\((i,j)\)</span>)
as returned by <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>. Since
the hessians are symmetric, their sparse representation contains only lower triangular elements.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, an
error will be raised. A successful call of this method will increase the internal hessians
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_hevals" title="pygmo.problem.get_hevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_hevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the hessians vector as an iterable Python object (e.g., list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) â€“ the decision vector whose hessians will be computed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the hessians of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of 1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of returned hessians does not match the corresponding hessians sparsity pattern dimensions, or
    the size of the return value is not equal to the fitness dimension</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><strong>NotImplementedError</strong></a> â€“ if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.hessians_sparsity">
<span class="sig-name descname"><span class="pre">hessians_sparsity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians_sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Hessians sparsity pattern.</p>
<p>This method will return the hessians sparsity pattern of the problem. Each component <span class="math notranslate nohighlight">\(l\)</span> of the hessians
sparsity pattern is a lexicographically sorted collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^l}{\partial x_i\partial x_j}\)</span>. Since the Hessian matrix is symmetric, only
lower triangular elements are allowed.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_hessians_sparsity" title="pygmo.problem.has_hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a dense pattern is assumed and
<span class="math notranslate nohighlight">\(n_f\)</span> sparsity patterns containing <span class="math notranslate nohighlight">\(((0,0),(1,0), (1,1), (2,0) ... (n_x-1,n_x-1))\)</span> will be returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP must return an iterable Python object of any kind. Each element of the
returned object will then be interpreted as a sparsity pattern in the same way as described in
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>. Specifically:</p>
<ul class="simple">
<li><p>if the element is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the element is itself an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the hessians sparsity patterns</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of 2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><strong>ValueError</strong></a> â€“ if the NumPy arrays returned by the UDP do not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of a returned iterable Python object does not consist of a collection of exactly
    2 elements, or if a sparsity pattern returned by the UDP is invalid (specifically, if it is not strictly sorted lexicographically,
    if the indices in the pattern are incompatible with the properties of the problem or if the size of the pattern
    differs from the size recorded upon construction)</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.12)"><strong>OverflowError</strong></a> â€“ if the NumPy arrays returned by the UDP contain integer values which are negative or outside an
    implementation-defined range</p></li>
<li><p><strong>unspecified</strong> â€“ any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.increment_fevals">
<span class="sig-name descname"><span class="pre">increment_fevals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.increment_fevals" title="Permalink to this definition">#</a></dt>
<dd><p>Increment the number of fitness evaluations.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.13.</span></p>
</div>
<p>This method will increase the internal counter of fitness evaluations by <em>n</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) â€“ the amount by which the internal counter of fitness evaluations will be increased</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> â€“ any exception thrown by failures at the intersection between C++ and Python (e.g.,
    type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.is_">
<span class="sig-name descname"><span class="pre">is_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_" title="Permalink to this definition">#</a></dt>
<dd><p>Check the type of the user-defined problem.</p>
<p>This method returns <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a> if <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract(t)</span></code></a> returns
<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) â€“ the type that will be compared to the type of the UDP</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>whether the UDP is of type <em>t</em> or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> â€“ any exception thrown by <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.is_stochastic">
<span class="sig-name descname"><span class="pre">is_stochastic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_stochastic" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <a class="reference internal" href="#pygmo.problem.has_set_seed" title="pygmo.problem.has_set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_set_seed()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygmo.problem.set_seed">
<span class="sig-name descname"><span class="pre">set_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.set_seed" title="Permalink to this definition">#</a></dt>
<dd><p>Set the seed for the stochastic variables.</p>
<p>This method will set the seed to be used in the fitness function to instantiate
all stochastic variables. If the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then
its <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method will be invoked. Otherwise, an error will be raised.
The <em>seed</em> parameter must be non-negative.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP must be able to take an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> as input parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) â€“ the desired seed value</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><strong>NotImplementedError</strong></a> â€“ if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.12)"><strong>OverflowError</strong></a> â€“ if <em>seed</em> is negative</p></li>
<li><p><strong>unspecified</strong> â€“ any exception raised by the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP or failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="algorithm.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Algorithm class</p>
      </div>
    </a>
    <a class="right-next"
       href="population.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Population class</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By pagmo development team
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      Â© Copyright 2021, pagmo development team.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>